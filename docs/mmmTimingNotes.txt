First up, bookmark this, I think it will be helpful: http://wiki.nesdev.com/w/index.php/Emulator_tests It’s ROMs for doing unit testing on your NES emulator (CPU, PPU, etc.).

Also doesn’t this talk in May look neat? https://us.pycon.org/2017/schedule/presentation/732/ 

Anyway …here’s what I gathered. It might not be 100% correct. It’s NTSC though because fuck PAL.

First, we need a clock cycle counter to be implemented in the CPU core, which it looks like Py65 has already, so that’s cool. The naïve implementation of an NES emulator would be that immediately after every CPU instruction is emulated, we emulate a PPU “step." The PPU runs at exactly 3x the clock speed of the CPU, so a step of the PPU is however much work it would have hypothetically done during the time that the CPU took to perform the last instruction. I say that’s the naïve implementation because it will be slower than running them in concurrent threads, but the synching mechanism would still have to be somewhat similar.

At any given point the PPU is in a deterministic state (or mode) depending on what point during the CRT screen draw operation it is. The PPU is either drawing a scanline (a horizontal line of pixels), waiting while there’s an h-blank (cathode ray going back to the left to draw another line), or waiting while there’s a v-blank (cathode ray going back to the origin to start a new frame). Each of these states has a duration that can be measured in CPU clock cycles. We could measure time in PPU clock cycles too but they’re synched at a perfect 3:1 ratio so it seems like it would just complicate things to think about and emulate 2 time sources. The duration of one frame-drawing operation is equivalent to 262 scanlines (20 of which is the V-blank … the other 2 lines are the first and last, the “dummy” scanlines), and each scanline takes 113.33-113.667 (depending on which reference you believe) CPU clock cycles to complete.

Emulated NES Memory can just be a big array (although it can also be seen as a map of emulated devices). Loading a ROM: map its contents to the emulated memory array. Technically, the ROM is bigger than the memory access range, so pieces of the ROM have to be swapped into view dynamically, a process known as memory bank swapping. But anyway the devices, including the PPU, are memory-mapped to regions of NES memory seen by the CPU. The emulated MMU could just be some hooks that call handler routines for whatever special range is being read/written, and these routines are where device emulation happens. Reads and writes to those special addresses have associated meanings: controller input, rendering a framebuffer to the actual display, turning notes and samples into actual sound.

It might seem that nothing about the PPU needs to be emulated on a shorter timescale than 1/60 second, since that’s the screen refresh and controller polling frequency. But the drawing of a framebuffer is not an atomic operation. It happens 3 pixels at a time, during which the game could be fucking with the PPU registers in every CPU instruction. Various games use PPU-register-writing tricks to create graphical effects. Game developers that were counting cycles (knowing the state of the PPU) wrote code to, for instance, change the PPU register that controls its drawing location mid-frame, to create split-screen effects or whatever.

The framebuffer is the representation of the screen, it’s a 256 by 240 pixel image. The PPU writes 3 pixels of a scanline for every CPU clock cycle, which might be the granularity at which we need to operate the PPU. If we do that, we don’t have to worry about complicating effects of mid-frame PPU-register-writing tricks. If stepping the PPU on every CPU instruction is too often and that make the emulator slow, I suppose we could emulate the PPU on a rougher granularity, like 1 scanline or 1 framebuffer. But then we’ll have to queue all the PPU-register-writes until we’re ready to step the PPU and mehhhh I guess it’s not that bad, just a little more complicated.

TL;DR: do a PPU.step() after each CPU.emulate_instruction(). In PPU.step(), determine how many CPU clock cycles passed during the last emulated CPU instruction, and call PPU.draw_three_pixels() the appropriate number of times.

P.S. The emulator needs to be tracking its own execution time and delaying appropriately, to execute at the processor's original speed. So after every frame has been drawn, it would be a good time to do a wait. You could put the delay in anywhere, but the time to render a frame is exactly 1/60 of a second so if we get it done sooner than that, we could just pause to make up the difference before continuing. Nothing will go wrong if we don’t except the game won’t play at the right speed.
